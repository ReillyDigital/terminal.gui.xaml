using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Xml.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ReillyDigital.Terminal.Gui.Xaml.Generation.Sources
{
	/// <summary>
	/// Defines the generation behavior for converting a XAML file to a partial class file.
	/// </summary>
	public class ClassSource
	{
		/// <summary>
		/// The class name of the generated partial class.
		/// </summary>
		public string ClassName { get; }

		/// <summary>
		/// The file name of the generated partial class.
		/// </summary>
		public string FileName { get; }

		/// <summary>
		/// The namespace name of the generated partial class.
		/// </summary>
		public string NamespaceName { get; } = null;

		/// <summary>
		/// The class name of the view model used by the generated partial class.
		/// </summary>
		private string ModelClassName { get; set; } = null;

		/// <summary>
		/// The XAML node to process for the namespace declaration.
		/// </summary>
		private BaseNamespaceDeclarationSyntax NamespaceSyntaxNode { get; } = null;

		/// <summary>
		/// The XAML node to process for the partial class declaration.
		/// </summary>
		private ClassDeclarationSyntax SyntaxNode { get; }

		/// <summary>
		/// The XAML syntax tree to process.
		/// </summary>
		private SyntaxTree SyntaxTree { get; }

		/// <summary>
		/// The XAML document to process.
		/// </summary>
		private XDocument Xaml { get; }

		/// <summary>
		/// The XAML file path to process.
		/// </summary>
		private string XamlFilePath { get; }

		/// <summary>
		/// Initializes a new instance of the <see cref="ClassSource" /> class.
		/// </summary>
		/// <param name="syntaxNode">The XAML node to process for the partial class declaration.</param>
		public ClassSource(ClassDeclarationSyntax syntaxNode)
		{
			SyntaxNode = syntaxNode;
			SyntaxTree = SyntaxNode.SyntaxTree;
			ClassName = SyntaxNode.Identifier.ToString();
			XamlFilePath = SyntaxTree.FilePath.Replace(".xaml.cs", ".xaml");
			Xaml = XDocument.Load(XamlFilePath);
			Func<SyntaxNode, BaseNamespaceDeclarationSyntax> getNamespaceSyntaxNode = null;
			getNamespaceSyntaxNode = (node) =>
			{
				if (node is BaseNamespaceDeclarationSyntax namespaceNode)
				{
					return namespaceNode;
				}
				var parent = node.Parent;
				if (parent is null)
				{
					return null;
				}
				return getNamespaceSyntaxNode(parent);
			};
			NamespaceSyntaxNode = getNamespaceSyntaxNode(SyntaxNode);
			NamespaceName = NamespaceSyntaxNode?.Name.ToString();
			FileName = (NamespaceName is null ? "" : $"{NamespaceName}.") + $"{ClassName}.xaml.g.cs";
		}

		/// <summary>
		/// Generates C# source code from a XAML view definition.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		public override string ToString() => XamlToSource();

		/// <summary>
		/// Generates C# source code from a XAML view definition.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string XamlToSource() => ""
			+ "// <auto-generated />\r\n"
			+ SourceFlags()
			+ SourceNamespace()
			+ SourceUsings()
			+ SourceClassWrapper(
					SourceDataContextProperty(),
					SourceNamedElementProperties(),
					SourceInitializeComponentMethod()
			)
			+ "";

		/// <summary>
		/// Generates C# source code for the class declaration of the generated partial class file.
		/// </summary>
		/// <param name="contents">The inner contents to be wrapped by the class declaration.</param>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceClassWrapper(params string[] contents) =>
			$"public partial class {ClassName} : ITerminalXamlView {{ {string.Join("\r\n", contents)} }}";

		/// <summary>
		/// Generates C# source code for the view model's DataContext property of the generated partial class file.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceDataContextProperty()
		{
			ModelClassName =
				Xaml.Root.Attributes().FirstOrDefault(
					(attribute) =>
						attribute.Name.Namespace == "http://schemas.microsoft.com/winfx/2006/xaml"
						&& attribute.Name.LocalName == "DataType"
				)?.Value;
			if (ModelClassName is null)
			{
				return "public object? DataContext { get; set; }";
			}
			var parts = ModelClassName.Split(':');
			var namespacePrefix = "";
			if (parts.Length > 1)
			{
				namespacePrefix = Xaml.Root.GetNamespaceOfPrefix(parts[0]).NamespaceName;
				var namespacePrefixParts = new Regex("^clr-namespace:([^;]+)(?:;assembly=.+)?$").Match(namespacePrefix);
				if (namespacePrefixParts.Success)
				{
					namespacePrefix = namespacePrefixParts.Groups[1].Value;
				}
				namespacePrefix += '.';
				ModelClassName = parts[1];
			}
			return ""
				+ $"private {namespacePrefix}{ModelClassName}? _DataContext;"
				+ $"public {namespacePrefix}{ModelClassName} DataContext"
				+ "{"
				+ "	get => _DataContext ?? throw new($\"{nameof(DataContext)} is not set.\");"
				+ "	set => _DataContext = value;"
				+ "}"
				+ "";
		}

		/// <summary>
		/// Generates C# source code for the file-level compiler flags of the generated partial class file.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceFlags() => "#nullable enable\r\n";

		/// <summary>
		/// Generates C# source code for the InitializeComponent method of the generated partial class file.
		/// This will contain the logic for initializing the outer View element defined by the XAML file.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceInitializeComponentMethod()
		{
			var returnValue = "public void InitializeComponent() {";
			var direction = "Vertical";
			foreach (var attribute in Xaml.Root.Attributes().Where((attribute) => !attribute.IsNamespaceDeclaration))
			{
				var attributeName = attribute.Name.LocalName;
				switch (attribute.Name.NamespaceName)
				{
					case "https://gitlab.com/reilly-digital/terminal.gui.xaml":
						{
							switch (attribute.Name.LocalName)
							{
								case "Direction":
									{
										direction = attribute.Value;
										continue;
									}
							}
							break;
						}
					case "http://schemas.microsoft.com/winfx/2006/xaml":
						{
							switch (attribute.Name.LocalName)
							{
								case "Class":
								case "DataType":
									{
										continue;
									}
							}
							break;
						}
				}
				var attributeNamespaceParts =
					new Regex("^clr-namespace:([^;]+)(?:;assembly=.+)?$").Match(attribute.Name.NamespaceName);
				var attributeNamespace = attributeNamespaceParts.Success ? attributeNamespaceParts.Groups[1].Value : "";
				if (
					attributeNamespace == "http://schemas.microsoft.com/winfx/2006/xaml"
					&& (attribute.Name.LocalName == "Class" || attribute.Name.LocalName == "DataType")
				)
				{
					continue;
				}
				var bindingParts = new Regex("^{Binding (.*)}$").Match(attribute.Value);
				if (bindingParts.Success)
				{
					if (!(ModelClassName is null))
					{
						returnValue += $"{attributeName} = DataContext.{bindingParts.Groups[1].Value};";
					}
					continue;
				}
				bindingParts = new Regex("^{TemplateBinding (.*)}$").Match(attribute.Value);
				if (bindingParts.Success)
				{
					if (!(ModelClassName is null))
					{
						returnValue += $"{attributeName} = {bindingParts.Groups[1].Value};";
					}
					continue;
				}
				returnValue += $"{attributeName} = \"{attribute.Value}\";";
			}
			var childIndex = 1;
			foreach (var child in Xaml.Root.Elements())
			{
				returnValue += ""
					+ SourceInitializeComponentMethodElement(child, childIndex, direction: direction)
					+ $"Add(element_{childIndex});"
					+ "";
				childIndex++;
			}
			returnValue += "}";
			return returnValue;
		}

		/// <summary>
		/// Generates C# source code for the InitializeComponent method of the generated partial class file.
		/// This will contain the logic for initializing each child View element defined by the XAML file.
		/// </summary>
		/// <param name="element">The XAML node representing the View element to added.</param>
		/// <param name="index">The index of the View element relative to its sibling child View elements.</param>
		/// <param name="parentVariableName">The generated variable name for the parent of this child View element.</param>
		/// <param name="direction">
		/// The render direction of this View element relative to its sibling child View elements. This should be either
		/// "Horizontal" or "Vertical".
		/// </param>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceInitializeComponentMethodElement(XElement element, int index, string parentVariableName = null, string direction = "Vertical")
		{
			var returnValue = "";
			var variableNamePrefix = $"{parentVariableName ?? "element"}_";
			var variableName = $"{variableNamePrefix}{index}";
			var childIndex = 1;
			if (element.Name.LocalName == "RoutedViewHost.DefaultContent")
			{
				returnValue += $"var {variableName} = new View();";
				returnValue += $"{variableName}.Height = Dim.Fill();";
				returnValue += $"{variableName}.Width = Dim.Fill();";
				foreach (var child in element.Elements())
				{
					returnValue += ""
						+ SourceInitializeComponentMethodElement(
							child, childIndex, parentVariableName: variableName, direction: direction
						)
						+ $"{variableName}.Add({variableName}_{childIndex});"
						+ "";
					childIndex++;
				}
				returnValue += $"{parentVariableName}.Navigate({variableName});";
				return returnValue;
			}
			var namespaceParts = new Regex("^clr-namespace:([^;]+)(?:;assembly=.+)?$").Match(element.Name.NamespaceName);
			var namespacePrefix = "";
			if (namespaceParts.Success)
			{
				namespacePrefix = $"{namespaceParts.Groups[1].Value}.";
			}
			returnValue += $"var {variableName} = new {namespacePrefix}{element.Name.LocalName}();";
			if (index > 1)
			{
				returnValue +=
					direction == "Horizontal"
						? $"{variableName}.X = Pos.Right({variableNamePrefix}{index - 1}) + 1;"
						: $"{variableName}.Y = Pos.Bottom({variableNamePrefix}{index - 1}) + 1;";
			}
			foreach (var attribute in element.Attributes().Where((attribute) => !attribute.IsNamespaceDeclaration))
			{
				var attributeName = attribute.Name.LocalName;
				switch (attribute.Name.NamespaceName)
				{
					case "https://gitlab.com/reilly-digital/terminal.gui.xaml":
						{
							switch (attribute.Name.LocalName)
							{
								case "Direction":
									{
										direction = attribute.Value;
										continue;
									}
							}
							break;
						}
					case "http://schemas.microsoft.com/winfx/2006/xaml":
						{
							switch (attribute.Name.LocalName)
							{
								case "Class":
								case "DataType":
									{
										continue;
									}
								case "Name":
									{
										returnValue += $"{attribute.Value} = {variableName};";
										continue;
									}
							}
							break;
						}
				}
				var bindingParts = new Regex("^{Binding (.*)}$").Match(attribute.Value);
				if (bindingParts.Success)
				{
					if (!(ModelClassName is null))
					{
						returnValue += $"{variableName}.{attributeName} = DataContext.{bindingParts.Groups[1].Value};";
					}
					continue;
				}
				bindingParts = new Regex("^{EventBinding (.*)}$").Match(attribute.Value);
				if (bindingParts.Success)
				{
					if (!(ModelClassName is null))
					{
						returnValue += $"{variableName}.{attributeName} += DataContext.{bindingParts.Groups[1].Value};";
					}
					continue;
				}
				bindingParts = new Regex("^{TemplateBinding (.*)}$").Match(attribute.Value);
				if (bindingParts.Success)
				{
					if (!(ModelClassName is null))
					{
						returnValue += $"{variableName}.{attributeName} = {bindingParts.Groups[1].Value};";
					}
					continue;
				}
				bindingParts = new Regex("^{TemplateEventBinding (.*)}$").Match(attribute.Value);
				if (bindingParts.Success)
				{
					if (!(ModelClassName is null))
					{
						returnValue += $"{variableName}.{attributeName} += {bindingParts.Groups[1].Value};";
					}
					continue;
				}
				returnValue += $"{variableName}.{attributeName} = \"{attribute.Value}\";";
			}
			foreach (var child in element.Elements())
			{
				returnValue += ""
					+ SourceInitializeComponentMethodElement(
						child, childIndex, parentVariableName: variableName, direction: direction
					)
					+ $"{variableName}.Add({variableName}_{childIndex});"
					+ "";
				childIndex++;
			}
			return returnValue;
		}

		/// <summary>
		/// Generates C# source code to define properties for any child View element containing the Name attribute of the
		/// http://schemas.microsoft.com/winfx/2006/xaml namespace.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceNamedElementProperties() =>
			string.Join(
				"",
				Xaml
					.Descendants()
					.Where((node) => node.Attributes().Any(
						(attribute) =>
							attribute.Name.NamespaceName == "http://schemas.microsoft.com/winfx/2006/xaml"
							&& attribute.Name.LocalName == "Name")
					)
					.Select(
						(node) =>
						{
							var name = node.Attributes().First((attribute) => attribute.Name.LocalName == "Name").Value;
							var namespaceParts =
								new Regex("^clr-namespace:([^;]+)(?:;assembly=.+)?$").Match(node.Name.NamespaceName);
							var namespacePrefix = namespaceParts.Success ? $"{namespaceParts.Groups[1].Value}." : "";
							return $"public {namespacePrefix}{node.Name.LocalName} {name} {{ get; private set; }} = default!;";
						}
					)
			);

		/// <summary>
		/// Generates C# source code for the namespace declaration of the generated partial class file.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceNamespace() => NamespaceName is null ? "" : $"namespace {NamespaceName};";

		/// <summary>
		/// Generates C# source code for the file-level using statements of the generated partial class file.
		/// </summary>
		/// <returns>
		/// A <see cref="string" /> of the generated source code.
		/// </returns>
		private string SourceUsings() => ""
			+ "using Terminal.Gui;"
			+ "using ReillyDigital.Terminal.Gui.Xaml;"
			+ "";
	}
}
